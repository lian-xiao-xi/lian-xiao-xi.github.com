<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[css布局-浮动与定位]]></title>
    <url>%2F2019%2F05%2F14%2Fcss%E5%B8%83%E5%B1%80-%E6%B5%AE%E5%8A%A8%E4%B8%8E%E5%AE%9A%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[每个网页都可以看成是由一层一层页面堆叠起来的，如下图所示。 把元素往 Z 轴方向移了一层，元素将脱离普通流，不再占据原本文档流那层的空间，还会覆盖下层的元素。 相对定位（设置了 position:relative 的元素）相对定位的元素依然在普通流中，可以通过 left right 等属性相对于以前位置移动元素，偏移前的位置仍然保留（即同一文档流的其他元素无法占据原位置）。 绝对定位（设置了 position: absolute 或 fixed 的元素） 绝对定位的元素将脱离文档流，不再占据原本文档流那层的空间； 绝对定位的元素会让元素变成行内块状元素，相当于给该元素设置了 display: inline-block； 设置了 position: absolute 的绝对定位元素在定位时将忽略其相对定位的元素的 padding。 设置了 position: absolute 的绝对定位元素设置的百分比的宽和高将针对其相对于定位的元素进行计算。 应用了 position: relative/absolute/fixed 的定位元素，margin 属性仍然有效。 浮动（设置了 float : left/right 的元素） 浮动元素会让父元素的高度缺失。 浮动就是个带有方位的 display:inline-block 属性。 同时设置了浮动和定位： 元素同时应用了 position: relative（top / left / bottom / right）和 float: left/right 属性后，则元素先浮动到相应的位置，然后再根据（top / left / bottom / right）所设置的距离来发生偏移；父元素仍无法获得此元素的高度； 元素同时应用了 position: absolute 和 float: right/left 属性，则 float 失效。 第一个元素应用了 position 之后会覆盖着接下来的 float: right/left 元素（如果两个元素所处的位置相同）。只有将 float 的元素的 position 设置成 relative 同时并设置较大得 z-index 值才能覆盖处于同一位置的 position 元素。 总结： position: absolute/fixed 和 float: left/right 都会让元素 inline-block 化。 float: left/right 致使父元素高度塌陷；position: absolute 致使父元素高度、宽度都塌陷（即脱离文档流）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js事件]]></title>
    <url>%2F2019%2F05%2F14%2Fjs%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[事件流事件流描述的是从页面中接收事件的顺序。事件流包括三个阶段：事件捕获阶段，处于目标阶段，事件冒泡阶段。 事件冒泡事件冒泡，即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点（文档节点）。 事件捕获事件捕获的思想是不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。事件捕获的用意在于在事件到达预定目标之前捕获它。 事件捕获一般只有在某些特殊需要时才会使用。 事件处理程序事件就是用户或浏览器执行的某种动作，如 click、mouseover 和 load 等，都是事件名。事件处理程序是响应某个事件的函数，事件处理程序的名字以“on”开头，因此 click 的事件处理程序就是 onclick。 为事件指定处理程序的方式有下面几种： HTML 事件处理程序 123456789&lt;body&gt; &lt;input type="button" value="click me" onclick="alert('hello')" /&gt; &lt;button type="button" id="mybtn" value="" onclick="sayHi()"&gt;按钮&lt;/button&gt; &lt;script type="text/javascript"&gt; function sayHi() &#123; alert("Hi"); &#125; &lt;/script&gt;&lt;/body&gt; 以上面的例子来说明，假如 sayHi() 函数是在按钮下方、页面最底部定义的。若用户在页面解析 sayHi() 函数之前就点击了按钮，就会引发错误。为此，很多 HTML 事件处理程序都会被封装在一个 try-catch 块中，以免错误不会浮出水面。 12345678&lt;button type="button" id="mybtn" value="username" onclick="try&#123;sayHi();&#125;catch(ex)&#123; &#125;"&gt; 按钮&lt;/button&gt; 通过 HTML 事件处理程序的最大缺点就是 HTML 与 JavaScript 代码紧密耦合，不利于后期维护。 DOM0 级事件处理程序 使用 DOM0 级方法指定的事件处理程序在元素的作用域中运行，换句话说，程序中的 this 引用当前元素。 1&lt;button type="button" name="button" id="mybtn" value=""&gt;按钮&lt;/button&gt;; 1234var btn = document.getElementById("mybtn");btn.onclick = function() &#123; alert(this.id);&#125;; // "mybtn" 删除通过上面两种方法方法指定的事件处理程序： 1btn.onclick = null; // 删除事件处理程序 DOM2 级事件处理程序 添加事件处理程序： addEventListener() 方法 删除事件处理程序： removeEventListener() 方法 这两个方法都接受 3 个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值（true 表示在事件捕获阶段调用事件处理程序，false 表示在冒泡阶段调用事件处理程序）。 通过 addEventListener() 添加的事件处理程序只能通过 removeEventListener() 移除；移除时传入的参数与添加事件处理程序时使用的参数相同，所以通过 addEventListener() 添加的匿名函数将无法移除。 12345678910111213141516171819function fun() &#123; alert(this.id);&#125;btn.addEventListener("click", fun, false);btn.removeEventListener("click", fun, false);btn.addEventListener( "click", function() &#123; alert("hello world"); &#125;, false);btn.removeEventListener( "click", function() &#123; alert("hello world"); &#125;, false); // 无法移除 IE 事件处理程序 IE8 及更早版本只支持事件冒泡。 添加事件处理程序： attachEvent() 方法 删除事件处理程序： detachEvent() 方法 使用 attachEvent() 方法指定的事件处理程序不是按照他们添加的顺序执行，而是以相反的顺序被执行。 这两个方法都接受两个参数：事件处理程序名称（而非事件的名称），作为事件处理程序的函数。与上述 DOM 方法一样，添加的匿名函数将无法移除。 1234567891011function fun() &#123; alert(this.id);&#125;btn.attachEvent("onclick", fun); // 注意这里的第一个参数是“onclick”，而不是“click”btn.detachEvent("onclick", fun);btn.attachEvent("onclick", function() &#123; alert("hello world");&#125;);btn.attachEvent("onclick", function() &#123; alert("hello world");&#125;); // 无法移除 使用 attachEvent() 方法指定的事件处理程序在全局作用域中运行，换句话说，程序中的 this 等于 window 。例如下面的例子： 123btn.attachEvent("onclick", function() &#123; alert(this === window); // true&#125;); 跨浏览器的事件处理程序 1234567891011121314151617181920212223242526272829303132333435363738394041// 跨浏览器的事件处理程序const EventUtil = &#123; addHandler: function(ele, type, handler) &#123; if (ele.addEventListener) &#123; ele.addEventListener(type, handler, false); &#125; else if (ele.attachEvent) &#123; ele.attachEvent("on" + type, handler); &#125; else &#123; ele["on" + type] = handler; &#125; &#125;, removeHandler: function(ele, type, handler) &#123; if (ele.removeEventListener) &#123; ele.removeEventListener(type, handler, false); &#125; else if (ele.detachEvent) &#123; ele.detachEvent("on" + type, handler); &#125; else &#123; ele["on" + type] = null; &#125; &#125;, getEvent: function(event) &#123; return event ? event : window.event; &#125;, getTarget: function(event) &#123; return event.target || event.srcElement; &#125;, preventDefault: function(event) &#123; if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; &#125; &#125;, stopPropagation: function(event) &#123; if (event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125; &#125;&#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js操作DOM]]></title>
    <url>%2F2019%2F05%2F13%2Fjs%E6%93%8D%E4%BD%9CDOM%2F</url>
    <content type="text"><![CDATA[节点节点类型每个节点都有一个 nodeType 属性，用于表示节点类型。nodeType 属性返回节点的类型。nodeType 是只读的。常用的节点类型如下图所示（图片摘自MDN） 节点关系 childNodes 属性以 NodeList 对象返回节点的子节点集合。NodeList 是一种类数组对象，用于保存一组有序的节点。NodeList 对象是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。 12var firstChild = someNode.childNodes[0];var len = someNode.length; firstChild 属性和 lastChild 属性分别返回指定节点的第一个和最后一个子节点。 parentNode 属性返回指定节点的父节点。 previousSibling 属性和 nextSibling 属性分别返回指定节点的上一个和下一个同级节点 Node.contains(otherNode) 来表示传入的节点是否为该节点的后代节点 Node.compareDocumentPosition(otherNode ) 方法用于比较当前节点与文档中的另一个节点的位置关系 Node.hasChildNodes() 方法用于判断当前节点是否有子节点，返回一个布尔值 操作节点 appendChild() 方法用于向 childNodes 列表的末尾插入一个节点。添加节点后，相关节点 DOM 结构得到更新，更新完成后返回新增的节点。 1234// someNode 有多个子节点var returnedNode = someNode.appendChild(someNode.firstChild);alert((returnedNode = someNode.firstChild)); //falsealert((returnedNode = someNode.lastChild)); //true insertBefore() 方法用于向 childNodes 列表的特定位置插入一个节点，并返回被插入的节点。这个方法接受两个参数：要插入的节点和作为参照的节点。被插入的节点将变成参照节点的前一个同胞节点（previousSibling）。 若参照节点是 null，则 insertBefore() 与 appendChild()执行相同的操作。 123// 插入到最后一个子节点前面returnedNode = someNode.insertBefore(newNode, someNode.lastChild);alert(newNode == someNode.childNodes[someNode.childNodes.length - 2]); //ture replaceChild() 方法用新节点替换某个子节点,并返回要替换的节点。这个方法接受两个参数：插入的新节点和要替换的节点。 12// 替换第一个子节点var returnedNode = someNode.replaceChild(newNode, someNode.firstChild); 注意：任何 DOM 节点都不能同时出现在文档的多个位置。所以，如果以上的三个方法中要新插入的节点已经是文档的一部分了，那么这个新插入的节点将从原来的位置转移到新位置。 removeChild() 方法用于移除节点。这个方法接受一个参数：要移除的节点。 12// 移除第一个子节点var formerFirstChild = someNode.removeChild(someNode.firstChild); ChildNode.remove() 方法把调用节点元素 ChildNode 从它所属的 DOM 树中删除。 12// id 为 'div-01' 的 div 被删掉了document.getElementById("div-01").remove(); cloneNode() 方法用于创建调用这个方法的节点的副本。此方法接受一个布尔值参数，表示是否进行深复制。深复制就是复制节点及其子节点树；浅复制是只复制节点本身。复制后返回的节点副本没有父节点，属于文档中的一个“孤儿”，所以通常还会通过 appendChild()、insertBefore()或 replaceChild() 将它添加到文档中。 normalize() 方法；规划化元素内的文本节点。如果在包含一个或多个文本节点的父元素上调用这个方法，则会将所有文本节点合并为一个节点，合并之后的新的文本节点的 nodeValue 等于合并前的每个文本节点的 nodeValue 值拼接起来的值。（浏览器自身永远不会创建相邻的文本节点，这种一个元素包含多个文本节点的情况一般是在操作 DOM 时产生的） 文档12345678910111213var htmlEle = document.documentElemnet; // 取得对&lt;html&gt;元素的引用var bodyEle = document.body; // 取得对&lt;body&gt;元素的引用var headEle = document.head || document.getElementsByTagName("head")[0]; //取得对&lt;head&gt;的引用;var title = document.title; //取得文档标题document.title = "new title"; //修改当前页面的标题var charset = document.charset; // 取得文档中实际使用的字符集document.charset = "UTF-8"; // 修改文档字符集var url = document.URL; //取得完整的URL（即地址栏中显示的URL）*只读*var domain = document.domain; //取得页面的域名var referrer = document.referrer; //取得链接到当前页面的那个页面的URL *只读*var doc_state = document.readyState; // 取得文档的当前状态（有两个可能的值：loading 和 complete）*只读*var focus_ele = document.activeElement; //取得文档中当前获得焦点的元素 *只读*var if_focus = document.hasFocus(); //取得用于检测文档是否获取焦点的布尔值。 元素通过 nodeName 或 tagName 属性访问元素的标签名。每个 HTML 元素都有下列属性： id, title, dir, dir(语言的方向), className 1alert(document.body.tagName); // "BODY" 插入标记 innerHTML 属性在读模式下，此属性返回与调用元素的所有子节点（包括元素、注释、文本节点）对应的 HTML 标记。写模式下，innerHTML 会根据指定的值创建新的 DOM 树，然后用这个 DOM 树完全替换调用元素原先的所有子节点。（通过 innerHTML 属性插入的 script 元素不会执行其中的脚本） insertAdjacentHTML( position,text) 方法这个方法接受两个参数：插入位置和要插入的 HTML 文本。第一个参数的可能值为：“beforebegin”,” afterbegin”,”beforeend”,”afterend”。注意: beforebegin 和 afterend 位置,仅在节点在树中且节点具有一个 parent 元素时工作 12345678// 作为前一个同辈元素插入element.insertAdjacentHTML("beforebegin", "&lt;p&gt;hello world !&lt;/p&gt;");// 插入元素内部的第一个子节点之前。element.insertAdjacentHTML("afterbegin", "&lt;p&gt;hello world !&lt;/p&gt;");// 插入元素内部的最后一个子节点之后。element.insertAdjacentHTML("beforeend", "&lt;p&gt;hello world !&lt;/p&gt;");// 作为后一个同辈元素插入element.insertAdjacentHTML("afterend", "&lt;p&gt;hello world !&lt;/p&gt;"); insertAdjacentElement(position, element)这个方法接受两个参数：插入位置和要插入的元素节点,此方法将一个给定的元素节点插入到相对于被调用的元素的给定的一个位置,返回插入的元素，插入失败则返回 null.注意: 当节点处于 DOM 树中而且有一个父元素的时候 beforebegin 和 afterend 操作才能起作用。 插入文本 textContent 属性Node.textContent 属性可以表示一个节点及其内部节点的文本内容。读模式下，textContent 会由浅入深将子文档树中的所有文本拼接起来。写模式下，会删除元素的所有子节点，插入包含相应文本值得文本节点。 insertAdjacentText ( position,text) 方法此方法和 insertAdjacentHTML() 方法用法相同，不过是第二个参数只能是纯文本。 元素属性12345678&lt;!-- 以下面这个元素为例 --&gt;&lt;div id="my_div" class="bd" title="body_text" my_attr="hello" data-appId="123"&gt;&lt;/div&gt; 1var div = document.getElementById("my_div"); // 取得对上面元素的引用 获取元素属性的数量通过元素的 attributes.length 属性 获取属性数量 1var len = div.attributes.lenght; 删除元素属性removeAttribute() 方法 用于彻底删除元素属性; 1div.removeAttribute("title"); //删除 title 属性 获取并操作属性方法 1： 通过元素自身直接获取、修改和添加属性 1234567// 获取元素属性var class = div.className;var id = div.id;// 修改元素属性div.title = "some other text"；// 添加元素属性div.lang= "en"; 方法 2（推荐）： 通过 getAttribute() 方法 获取属性， setAttribute() 方法 修改和添加属性 123456789//获取元素属性var title = div.getAttribute("title");var my_attr = div.getAttribute("my_attr");// 修改元素属性div.setAttribute("class", "ft");div.setAttribute("my_attr", "hi");// 给添加属性div.setAttribute("lang", "en");div.setAttribute("my_name", "Tom"); 上述两种方法的区别：方法 2 既可以获取标准的属性还可以获取自定义属性，而方法 1 只能访问标准的属性无法访问自定义属性。 自定义数据属性还可以通过元素的 dataset 属性 来获取和修改自定义属性的值 12var appId = div.dataset.appId; // 取得自定义属性的值div.dataset.appId = "234"; // 修改自定义属性的值 创建元素1var div = document.createElement("div"); // 创建一个&lt;div&gt;元素 由于新创建的元素属于文档中的一个“孤儿”，所以通常还会通过 appendChild()、insertBefore()或 replaceChild() 将它添加到文档中。 获取对元素的引用 取得对文档的子元素节点的引用 123var head = document.head || document.getElementsByTagName("head")[0]; //取得对&lt;head&gt;的引用var html = document.documentElement; //取得对&lt;html&gt;的引用var body = document.body; //取得对&lt;body&gt;的引用 取得对特定的某个或某组元素的引用 getElementById() 方法 无法通过 HTML 元素调用该方法getElementsByClassName() 方法 接收一个包含一或多个类名的字符串作为参数，返回带有指定类名的所有元素的 Nodelist 集合。 1var eles = document.getElementByClassName("btn banner"); // 取得所有类中包含“btn”和“banner”的元素 getElementsByTagName() 方法 返回带有指定标签名的对象的集合。 1234var all_ele = document.getElementsByTagName("*"); //取得文档中的所有元素var images = document.getElementsByTagName("img"); //取得页面中所有的&lt;img&gt;元素alert(images.length); //输出&lt;img&gt;元素的数量alert(images[0].src); //输出第一个图片元素的src属性 getElementsByName() 方法; 返回带有指定名称的对象的集合，该方法常用于取得单选按钮。无法通过 HTML 元素调用该方法。querySelector() 方法 querySelector() 方法接收一个 CSS 选择符作为参数，返回与该模式匹配的第一个元素。如果没有找到匹配的元素，则返回 null 12345var p_first = document.querySelector("p"); //获取文档中第一个&lt;p&gt; 元素var example = document.querySelector(".example"); // 获取文档中 class="example" 的第一个元素var p_example = document.querySelector("p.example"); //获取文档中 class="example" 的第一个&lt;p&gt;元素var a_target = document.querySelector("a[target]"); // 获取文档中有"target"属性的第一个&lt;a&gt;元素var p_em = document.querySelector("p em"); // 获取文档中第一个&lt;p&gt;元素内的第一个&lt;em&gt;元素 querySelectorAll() 方法 querySelectorAll() 方法接收一个 CSS 选择符作为参数，返回与该模式匹配的所有元素的集合。 元素关系 children 属性 元素的 children 属性中只包含元素中同样还是元素的子节点；childNodes 的元素版。 childElementCount 属性 返回子元素（不包括注释和文本节点）的个数 firstElementChild 属性 指向第一个子元素；firstChild 的元素版 lastElementChild 属性指向最后一个子元素；lastChild 的元素版 previousElementSibling 属性指向前一个同级元素；previousSibling 的元素版 nextElementSibling 属性指向后一个同级元素；nextSibling 的元素版 parentElement 属性 返回当前节点的父元素节点,如果该元素没有父节点,或者父节点不是一个元素节点.则 返回 null 操作元素 hasFocus() 方法 返回布尔值，用于检测文档(或文档内的任一元素)是否获得焦点。 matchesSelector() 方法 接收一个 CSS 选择符作为参数，如果调用函数与该选择符匹配，返回 true；否则，返回 false。 元素样式classList 属性返回元素的 class 类名列表集合，返回的列表集合也有一个 length 属性来表示类的个数，该属性用于在元素中添加，移除及切换 CSS 类。classList 属性是只读的，但可以使用下面的方法修改它。 add(value): 将给定的字符串值添加到列表中。如果值已经存在，则不添加。 contains(value): 表示列表中是否存在给定的值，如果存在则返回 true，否则返回 false。 remove(value): 从列表中删除给定的字符串。 toggle(value): 如果列表中已经存在给定的值则删除它；如果列表中没有给定的值则添加它。 文本 通过 nodeValue 或 data 属性 获取文本节点的内容。 通过 length 属性 获取文本节点中字符的数目。 使用 document.createTextNode() 创建新文本节点 123456// 创建一个&lt;div&gt;元素并向其中添加一个文本节点var ele = document.createElement("div");ele.className = "message";var text = document.createTextNode("hello world");ele.appendChild(text);document.body.appendChild(ele); 操作文本 appendData(text): 将 text 添加到节点的末尾。 deleteDate(offset, count): 从 offset 指定的位置开始删除 count 个字符。 insertData(offset, text): 在 offset 指定的位置插入 text。 replaceData(offset, count, text): 用 text 替换从 offset 指定的位置开始到 offset+count 为止处的文本。 substringData(offset, count): 提取从 offset 指定的位置开始到 offset+count 为止处的字符串。 splitText(offset): 从 offset 指定的位置将当前文本节点分成两个文本节点。 分割文本节点是从文本节点中提取数据的一种常用的 DOM 技术。 123456// 以上面创建的&lt;div&gt;元素为例// 分割文本节点var newNode = ele.firstChild.splitText(5);alert(ele.firstChild.nodeValue); // "hello"alert(newNode.nodeValue); //" world"alert(ele.childNodes.length); // 2 样式通过 style 对象获取并操作元素的内联样式这个 style 对象包含着通过元素 style 属性设置的内联样式信息，不包含外部样式表或嵌入样式表继承层叠而来的样式。 style 对象的一些属性和方法 ： cssText： 读模式下返回 style 属性中 CSS 代码的内部表示；写模式下，赋给 cssText 的值会重写 元素 style 属性的值。length： 元素 style 属性中的 css 属性数量parentRule： 表示 css 信息的 CSSRule 对象getPropertyValue(propertyName)： 返回给定属性的字符串值item(index)： 返回给定位置的 css 属性的名称removePropertyValue(propertyName)： 从元素 style 属性中删除给定属性setProperty(propertyName,value,priority)： 将给定属性设置为相应的值，并加上优先权标志（“important” 或者一个空字符串） 通过document.defaultView.getComputedStyle()获取元素的计算样式此方法接受两个参数：目标元素和一个伪元素字符串（例如”:after”），如果不需要伪元素信息第二个参数可以为 null。 注意： 计算的样式是只读的；计算的样式包含浏览器的默认样式。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
</search>
